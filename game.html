<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script defer src="https://cloud.umami.is/script.js" data-website-id="3cbe6df4-3577-4d6f-9fc2-5440fe190e97"></script>
  <title>Puzzle Quest</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,600;1,400;1,500&family=Lora:ital@0;1&display=swap"
    rel="stylesheet" />
  <style>
    :root {
      --bg: #1a0a0e;
      --glow: rgba(180, 50, 70, 0.25);
      --accent: #c94060;
      --accent-dim: #7a1e30;
      --text: #f5e6e8;
      --text-soft: #d4b0b8;
      --text-muted: #9a6b7a;
      --text-title: #f0d0d5;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: 'Lora', serif;
      overflow-x: hidden;
      position: relative;
      padding-bottom: 60px;
      user-select: none;
    }

    body::before {
      content: '';
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 600px;
      height: 600px;
      background: radial-gradient(circle, var(--glow) 0%, transparent 70%);
      pointer-events: none;
      z-index: 0;
    }

    /* Nav */
    nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 18px 12px;
      background: linear-gradient(180deg, rgba(26, 10, 14, 0.9) 0%, transparent 100%);
    }

    nav a {
      color: var(--text-muted);
      text-decoration: none;
      font-family: 'Playfair Display', serif;
      font-size: 0.82rem;
      letter-spacing: 2.5px;
      text-transform: uppercase;
      transition: color 0.3s;
      position: relative;
      z-index: 1;
    }

    nav a:hover,
    nav a.active {
      color: var(--accent);
    }

    nav a.active::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--accent);
    }

    /* Petals Animation */
    .petal {
      position: fixed;
      border-radius: 50% 0 50% 50%;
      opacity: 0;
      background: radial-gradient(circle, var(--accent), var(--accent-dim));
      animation: fall linear infinite;
      z-index: 0;
      pointer-events: none;
    }

    .petal:nth-child(1) {
      left: 8%;
      animation-duration: 9s;
      animation-delay: 0s;
      width: 9px;
      height: 9px
    }

    .petal:nth-child(2) {
      left: 30%;
      animation-duration: 12s;
      animation-delay: 3s;
      width: 7px;
      height: 7px
    }

    .petal:nth-child(3) {
      left: 55%;
      animation-duration: 10s;
      animation-delay: 5s;
      width: 11px;
      height: 11px
    }

    .petal:nth-child(4) {
      left: 78%;
      animation-duration: 11s;
      animation-delay: 1.5s;
      width: 8px;
      height: 8px
    }

    .petal:nth-child(5) {
      left: 92%;
      animation-duration: 9s;
      animation-delay: 4s;
      width: 10px;
      height: 10px
    }

    @keyframes fall {
      0% {
        top: -20px;
        opacity: 0;
        transform: rotate(0deg) translateX(0)
      }

      10% {
        opacity: 0.7
      }

      90% {
        opacity: 0.4
      }

      100% {
        top: 105vh;
        opacity: 0;
        transform: rotate(360deg) translateX(40px)
      }
    }

    /* Page Layout */
    .page {
      position: relative;
      z-index: 1;
      max-width: 800px;
      margin: 0 auto;
      padding: 110px 20px 40px;
    }

    .divider {
      width: 60px;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      margin: 0 auto 24px;
    }

    .page-title {
      font-family: 'Playfair Display', serif;
      font-size: 2.2rem;
      font-weight: 400;
      font-style: italic;
      color: var(--text-title);
      margin-bottom: 8px;
      text-align: center;
    }

    .page-subtitle {
      font-family: 'Playfair Display', serif;
      font-size: 0.78rem;
      color: var(--text-muted);
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 12px;
      text-align: center;
    }

    .instructions {
      font-size: 0.82rem;
      color: var(--text-soft);
      text-align: center;
      max-width: 480px;
      margin: 0 auto 36px;
      line-height: 1.7;
      font-style: italic;
    }

    /* Progress Bar */
    .progress-bar {
      max-width: 420px;
      margin: 0 auto 32px;
      text-align: center;
    }

    .reset-all-container {
      text-align: center;
      margin-bottom: 20px;
    }

    .reset-all-btn {
      background: transparent;
      border: 1px solid rgba(201, 64, 96, 0.3);
      color: var(--text-muted);
      font-family: 'Playfair Display', serif;
      font-size: 0.7rem;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      padding: 6px 16px;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .reset-all-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(201, 64, 96, 0.05);
    }

    .progress-label {
      font-family: 'Playfair Display', serif;
      font-size: 0.7rem;
      color: var(--accent);
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    .progress-track {
      height: 8px;
      background: rgba(201, 64, 96, 0.15);
      border-radius: 10px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-dim), var(--accent));
      width: 0%;
      transition: width 0.5s ease;
    }

    /* Game Cards */
    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }

    .game-card {
      background: rgba(201, 64, 96, 0.05);
      border: 1px solid rgba(201, 64, 96, 0.15);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      transition: border-color 0.3s, box-shadow 0.3s;
      position: relative;
    }

    .game-card:hover {
      border-color: rgba(201, 64, 96, 0.3);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    .game-card.completed::before {
      content: 'âœ“';
      position: absolute;
      top: 12px;
      right: 12px;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      font-weight: bold;
    }

    .game-reset {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(201, 64, 96, 0.2);
      border: 1px solid rgba(201, 64, 96, 0.3);
      color: var(--text-soft);
      font-size: 0.7rem;
      padding: 4px 8px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      opacity: 0;
    }

    .game-card.completed .game-reset {
      opacity: 1;
    }

    .game-reset:hover {
      background: rgba(201, 64, 96, 0.4);
      color: var(--accent);
    }

    .game-title {
      font-family: 'Playfair Display', serif;
      font-size: 1.15rem;
      color: var(--text-title);
      margin-bottom: 8px;
      font-weight: 400;
    }

    .game-desc {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 14px;
      line-height: 1.6;
    }

    .game-btn {
      background: transparent;
      border: 1px solid var(--accent);
      color: var(--accent);
      font-family: 'Playfair Display', serif;
      font-size: 0.75rem;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      padding: 8px 20px;
      border-radius: 20px;
      cursor: pointer;
      transition: background 0.3s, color 0.3s;
    }

    .game-btn:hover:not(:disabled) {
      background: var(--accent);
      color: #fff;
    }

    /* Final Puzzle */
    .final-section {
      display: none;
      text-align: center;
      margin-top: 40px;
      padding: 30px 20px;
      border-radius: 14px;
      background: rgba(201, 64, 96, 0.08);
      border: 1px solid rgba(201, 64, 96, 0.2);
    }

    .final-section.show {
      display: block;
    }

    .final-title {
      font-family: 'Playfair Display', serif;
      font-style: italic;
      font-size: 1.6rem;
      color: var(--text-title);
      margin-bottom: 10px;
    }

    .final-desc {
      font-size: 0.82rem;
      color: var(--text-soft);
      margin-bottom: 24px;
      font-style: italic;
    }

    .puzzle-assembly {
      display: grid;
      grid-template-columns: repeat(2, 140px);
      grid-template-rows: repeat(2, 140px);
      gap: 8px;
      margin: 0 auto;
      justify-content: center;
      transition: gap 0.5s ease;
    }

    .puzzle-assembly.complete {
      gap: 0px;
    }

    .puzzle-slot {
      border: 2px dashed rgba(201, 64, 96, 0.3);
      border-radius: 8px;
      background: rgba(26, 10, 14, 0.4);
      position: relative;
      transition: border-color 0.3s, border-radius 0.5s;
    }

    .puzzle-slot.filled {
      border-color: var(--accent);
      background: transparent;
    }

    .puzzle-slot.correct {
      border-color: rgba(76, 175, 80, 0.8);
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
    }

    .puzzle-assembly.complete .puzzle-slot {
      border: none;
      border-radius: 0;
      box-shadow: none;
    }

    .puzzle-slot img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 6px;
      transition: border-radius 0.5s;
    }

    .puzzle-assembly.complete .puzzle-slot img {
      border-radius: 0;
    }

    @keyframes shake {

      0%,
      100% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-5px);
      }

      75% {
        transform: translateX(5px);
      }
    }

    .pieces-pool {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-top: 24px;
    }

    .piece-wrap {
      width: 120px;
      height: 120px;
      border: 1px solid rgba(201, 64, 96, 0.2);
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .piece-wrap:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 16px rgba(201, 64, 96, 0.3);
    }

    .piece-wrap.placed {
      opacity: 0.3;
      pointer-events: none;
    }

    .puzzle-piece {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .puzzle-controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 200;
      background: rgba(26, 10, 14, 0.92);
      overflow-y: auto;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: var(--bg);
      border: 1px solid rgba(201, 64, 96, 0.25);
      border-radius: 14px;
      padding: 30px 24px;
      max-width: 500px;
      width: 100%;
      position: relative;
      text-align: center;
    }

    .modal-close {
      position: absolute;
      top: 12px;
      right: 12px;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.4rem;
      cursor: pointer;
      line-height: 1;
      transition: color 0.3s;
    }

    .modal-close:hover {
      color: var(--accent);
    }

    .modal-title {
      font-family: 'Playfair Display', serif;
      font-style: italic;
      font-size: 1.5rem;
      color: var(--text-title);
      margin-bottom: 18px;
    }

    .game-container {
      margin-top: 20px;
    }

    @media(max-width:600px) {
      .page {
        padding: 100px 16px 40px;
      }

      .page-title {
        font-size: 1.75rem;
      }

      .games-grid {
        grid-template-columns: 1fr;
      }

      .puzzle-assembly {
        grid-template-columns: repeat(2, 110px);
        grid-template-rows: repeat(2, 110px);
      }

      .piece-wrap {
        width: 100px;
        height: 100px;
      }
    }

    /* Custom Alert Modal */
    .custom-alert {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 300;
      background: rgba(26, 10, 14, 0.95);
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s;
    }

    .custom-alert.show {
      display: flex;
    }

    .custom-alert-content {
      background: var(--bg);
      border: 2px solid var(--accent);
      border-radius: 16px;
      padding: 40px 30px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 10px 40px rgba(201, 64, 96, 0.3);
      animation: slideUp 0.3s;
    }

    .custom-alert-title {
      font-family: 'Playfair Display', serif;
      font-style: italic;
      font-size: 1.8rem;
      color: var(--text-title);
      margin-bottom: 15px;
    }

    .custom-alert-message {
      font-size: 0.95rem;
      color: var(--text-soft);
      margin-bottom: 25px;
      line-height: 1.6;
    }

    .custom-alert-btn {
      background: var(--accent);
      border: none;
      color: #fff;
      font-family: 'Playfair Display', serif;
      font-size: 0.85rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      padding: 12px 30px;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .custom-alert-btn:hover {
      background: var(--accent-dim);
      transform: scale(1.05);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        transform: translateY(30px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Custom Confirm Modal */
    .custom-confirm {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 300;
      background: rgba(26, 10, 14, 0.95);
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s;
    }

    .custom-confirm.show {
      display: flex;
    }

    .custom-confirm-content {
      background: var(--bg);
      border: 2px solid var(--accent);
      border-radius: 16px;
      padding: 40px 30px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 10px 40px rgba(201, 64, 96, 0.3);
      animation: slideUp 0.3s;
    }

    .custom-confirm-title {
      font-family: 'Playfair Display', serif;
      font-style: italic;
      font-size: 1.5rem;
      color: var(--text-title);
      margin-bottom: 15px;
    }

    .custom-confirm-message {
      font-size: 0.95rem;
      color: var(--text-soft);
      margin-bottom: 25px;
      line-height: 1.6;
    }

    .custom-confirm-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .custom-confirm-btn {
      background: transparent;
      border: 1px solid var(--accent);
      color: var(--accent);
      font-family: 'Playfair Display', serif;
      font-size: 0.8rem;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      padding: 10px 24px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .custom-confirm-btn:hover {
      background: var(--accent);
      color: #fff;
    }

    .custom-confirm-btn.primary {
      background: var(--accent);
      color: #fff;
    }

    .custom-confirm-btn.primary:hover {
      background: var(--accent-dim);
    }
  </style>
</head>

<body>

  <nav>
    <a href="index.html">Home</a>
    <a href="story.html">Story</a>
    <a href="gallery.html">Gallery</a>
    <a href="game.html" class="active">Game</a>
  </nav>

  <div class="petal"></div>
  <div class="petal"></div>
  <div class="petal"></div>
  <div class="petal"></div>
  <div class="petal"></div>

  <!-- Custom Alert Modal -->
  <div class="custom-alert" id="customAlert">
    <div class="custom-alert-content">
      <h2 class="custom-alert-title" id="alertTitle">Success!</h2>
      <p class="custom-alert-message" id="alertMessage">You did it!</p>
      <button class="custom-alert-btn" onclick="closeAlert()">Continue</button>
    </div>
  </div>

  <!-- Custom Confirm Modal -->
  <div class="custom-confirm" id="customConfirm">
    <div class="custom-confirm-content">
      <h2 class="custom-confirm-title" id="confirmTitle">Confirm</h2>
      <p class="custom-confirm-message" id="confirmMessage">Are you sure?</p>
      <div class="custom-confirm-buttons">
        <button class="custom-confirm-btn" onclick="closeConfirm(false)">Cancel</button>
        <button class="custom-confirm-btn primary" onclick="closeConfirm(true)">Confirm</button>
      </div>
    </div>
  </div>

  <div class="page">
    <div class="divider"></div>
    <h1 class="page-title">Puzzle Quest</h1>
    <p class="page-subtitle">Unlock the Mystery</p>
    <p class="instructions">Complete all 4 puzzles to earn the pieces, then assemble them to reveal your surprise.</p>

    <div class="reset-all-container">
      <button class="reset-all-btn" onclick="resetAllGames()">Reset All Games</button>
    </div>

    <div class="progress-bar">
      <div class="progress-label"><span id="progressText">0 / 4 Completed</span></div>
      <div class="progress-track">
        <div class="progress-fill" id="progressFill"></div>
      </div>
    </div>

    <div class="games-grid">
      <div class="game-card" id="card-zip">
        <button class="game-reset" onclick="resetGame('zip', event)">Reset</button>
        <h3 class="game-title">Heart Zip</h3>
        <p class="game-desc">Connect the path from 1 to 27 in the shape of a heart.</p>
        <button class="game-btn" onclick="openGame('zip')">Play</button>
      </div>

      <div class="game-card" id="card-sudoku">
        <button class="game-reset" onclick="resetGame('sudoku', event)">Reset</button>
        <h3 class="game-title">6x6 Sudoku</h3>
        <p class="game-desc">Fill the grid with 1-6. Each 2x3 box must be unique.</p>
        <button class="game-btn" onclick="openGame('sudoku')">Play</button>
      </div>

      <div class="game-card" id="card-queens">
        <button class="game-reset" onclick="resetGame('queens', event)">Reset</button>
        <h3 class="game-title">4 Queens</h3>
        <p class="game-desc">Place 4 queens on the board so none can attack each other.</p>
        <button class="game-btn" onclick="openGame('queens')">Play</button>
      </div>

      <div class="game-card" id="card-tango">
        <button class="game-reset" onclick="resetGame('tango', event)">Reset</button>
        <h3 class="game-title">Memory Match</h3>
        <p class="game-desc">Find all 4 matching pairs of hearts.</p>
        <button class="game-btn" onclick="openGame('tango')">Play</button>
      </div>
    </div>

    <div class="final-section" id="finalSection">
      <div class="final-title">You Did It! ğŸ’•</div>
      <p class="final-desc">Now drag each piece to its correct spot to reveal the full picture.</p>
      <div class="puzzle-assembly" id="assemblyGrid">
        <div class="puzzle-slot" data-slot="0"></div>
        <div class="puzzle-slot" data-slot="1"></div>
        <div class="puzzle-slot" data-slot="2"></div>
        <div class="puzzle-slot" data-slot="3"></div>
      </div>
      <div class="pieces-pool" id="piecesPool"></div>
      <div class="puzzle-controls">
        <button class="game-btn" onclick="redoPuzzle()">Redo Puzzle</button>
      </div>
    </div>
  </div>

  <div class="modal" id="gameModal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeGame()">&times;</button>
      <h2 class="modal-title" id="modalTitle">Game</h2>
      <div class="game-container" id="gameContainer"></div>
    </div>
  </div>

  <script>
    // â”€â”€ CUSTOM ALERT SYSTEM â”€â”€
    function showAlert(title, message) {
      document.getElementById('alertTitle').textContent = title;
      document.getElementById('alertMessage').textContent = message;
      document.getElementById('customAlert').classList.add('show');
    }

    function closeAlert() {
      document.getElementById('customAlert').classList.remove('show');
    }

    // â”€â”€ CUSTOM CONFIRM SYSTEM â”€â”€
    let confirmCallback = null;

    function showConfirm(title, message) {
      return new Promise((resolve) => {
        confirmCallback = resolve;
        document.getElementById('confirmTitle').textContent = title;
        document.getElementById('confirmMessage').textContent = message;
        document.getElementById('customConfirm').classList.add('show');
      });
    }

    function closeConfirm(result) {
      document.getElementById('customConfirm').classList.remove('show');
      if (confirmCallback) {
        confirmCallback(result);
        confirmCallback = null;
      }
    }

    // â”€â”€ STATE â”€â”€
    let completed = JSON.parse(localStorage.getItem('gamesCompleted') || '{"zip":false,"sudoku":false,"queens":false,"tango":false}');

    // â”€â”€ INIT â”€â”€
    function init() {
      updateProgress();
      if (allCompleted()) showFinalPuzzle();
    }

    function updateProgress() {
      const count = Object.values(completed).filter(Boolean).length;
      document.getElementById('progressText').textContent = `${count} / 4 Completed`;
      document.getElementById('progressFill').style.width = (count * 25) + '%';
      Object.keys(completed).forEach(game => {
        if (completed[game]) document.getElementById(`card-${game}`).classList.add('completed');
      });
    }

    function resetGame(game, event) {
      event.stopPropagation();
      const gameName = game.charAt(0).toUpperCase() + game.slice(1).replace('zip', 'Heart Zip').replace('sudoku', '6x6 Sudoku').replace('queens', '4 Queens').replace('tango', 'Memory Match');

      showConfirm('Reset Game?', `Are you sure you want to reset ${gameName}? This will erase your progress for this game.`).then((confirmed) => {
        if (confirmed) {
          completed[game] = false;
          localStorage.setItem('gamesCompleted', JSON.stringify(completed));
          document.getElementById(`card-${game}`).classList.remove('completed');
          updateProgress();

          // Hide final puzzle if it was showing
          if (!allCompleted()) {
            document.getElementById('finalSection').classList.remove('show');
          }
        }
      });
    }

    function resetAllGames() {
      showConfirm('Reset All Games?', 'Are you sure you want to reset ALL games? This will erase all your progress and you will need to complete all puzzles again.').then((confirmed) => {
        if (confirmed) {
          completed = { zip: false, sudoku: false, queens: false, tango: false };
          localStorage.setItem('gamesCompleted', JSON.stringify(completed));
          Object.keys(completed).forEach(game => {
            document.getElementById(`card-${game}`).classList.remove('completed');
          });
          updateProgress();
          document.getElementById('finalSection').classList.remove('show');
        }
      });
    }

    function allCompleted() { return Object.values(completed).every(Boolean); }

    function markComplete(game) {
      if (!completed[game]) {
        completed[game] = true;
        localStorage.setItem('gamesCompleted', JSON.stringify(completed));
        updateProgress();
        if (allCompleted()) {
          setTimeout(() => { closeGame(); showFinalPuzzle(); }, 1000);
        }
      }
    }

    // â”€â”€ MODAL â”€â”€
    function openGame(game) {
      document.getElementById('gameModal').classList.add('show');
      loadGame(game);
    }

    function closeGame() {
      document.getElementById('gameModal').classList.remove('show');
      document.getElementById('gameContainer').innerHTML = '';
    }

    function loadGame(game) {
      const container = document.getElementById('gameContainer');
      const title = document.getElementById('modalTitle');
      if (game === 'zip') {
        title.textContent = 'Heart Zip';
        container.innerHTML = createZipGame();
        initZipGame();
      } else if (game === 'sudoku') {
        title.textContent = '6x6 Sudoku';
        container.innerHTML = createSudoku();
        initSudoku();
      } else if (game === 'queens') {
        title.textContent = '4 Queens';
        container.innerHTML = createQueens();
        initQueens();
      } else if (game === 'tango') {
        title.textContent = 'Memory Match';
        container.innerHTML = createTango();
        initTango();
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME 1: HEART ZIP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function createZipGame() {
      return `<style>
.zip-grid {
    display:grid; grid-template-columns:repeat(7, 40px); grid-template-rows:repeat(6, 40px);
    gap:4px; margin:0 auto; justify-content:center; touch-action:none;
}
.zip-cell {
    background:rgba(201,64,96,0.08); border:1px solid rgba(201,64,96,0.15);
    border-radius:50%; display:flex; align-items:center; justify-content:center;
    font-size:0.9rem; font-weight:bold; color:var(--text-soft);
    cursor:pointer; transition:all 0.15s; user-select:none;
}
.zip-cell.void { opacity:0; pointer-events:none; }
.zip-cell.active { background:var(--accent); color:#fff; box-shadow:0 0 10px var(--glow); border-color:var(--accent); transform:scale(1.1); }
.zip-cell.head { background:#fff; color:var(--accent); transform:scale(1.2); z-index:2; }
.zip-cell.waypoint { border:2px solid var(--accent); color:var(--accent); }
.zip-cell.waypoint.active { border-color:#fff; color:#fff; background:var(--accent); }
.zip-controls { margin-top:15px; display:flex; gap:10px; justify-content:center; }
</style>
<div class="zip-grid" id="zipGrid"></div>
<div class="zip-controls">
    <button class="game-btn" onclick="resetZip()">Reset</button>
</div>`;
    }

    function initZipGame() {
      const cols = 7;
      // null = void, 0 = empty playable, number = waypoint
      // This creates a heart shape mask
      const level = [
        [null, 18, 0, null, 11, 0, null], // Row 0
        [0, 0, 0, 15, 0, 0, 8],   // Row 1
        [21, 0, 0, 0, 0, 0, 0],   // Row 2
        [null, 26, 24, 27, 0, 5, null], // Row 3
        [null, null, 25, 0, 3, null, null], // Row 4
        [null, null, null, 1, null, null, null]  // Row 5
      ];
      // Total playable nodes = 27
      let path = [];
      let isDrawing = false;
      let bonusIlluminated = false;

      renderGrid();

      function renderGrid() {
        const gridEl = document.getElementById('zipGrid');
        gridEl.innerHTML = '';

        level.forEach((row, r) => {
          row.forEach((val, c) => {
            const cell = document.createElement('div');

            if (val === null) {
              cell.className = 'zip-cell void';
            } else {
              const pathIdx = path.findIndex(p => p.r === r && p.c === c);
              const isPath = pathIdx !== -1;
              let classes = 'zip-cell';
              if (val > 0) classes += ' waypoint';
              if (isPath) classes += ' active';
              if (isPath && pathIdx === path.length - 1) classes += ' head';

              // Special: illuminate 26 and 27 when bonus is triggered
              if (bonusIlluminated && (val === 26 || val === 27)) {
                classes += ' active';
              }

              cell.className = classes;
              // Show Number if it's a waypoint or current head
              cell.textContent = val > 0 ? val : (isPath ? pathIdx + 1 : '');

              cell.onmousedown = (e) => startDraw(r, c);
              cell.onmouseenter = (e) => enterCell(r, c);
              cell.ontouchstart = (e) => { e.preventDefault(); startDraw(r, c); };
            }
            gridEl.appendChild(cell);
          });
        });
        gridEl.ontouchmove = handleTouchMove;
      }

      function startDraw(r, c) {
        if (level[r][c] === 1) {
          path = [{ r, c }];
          isDrawing = true;
          bonusIlluminated = false;
          renderGrid();
        } else if (path.length > 0) {
          const head = path[path.length - 1];
          if (head.r === r && head.c === c) isDrawing = true;
        }
      }

      function enterCell(r, c) {
        if (!isDrawing) return;
        const head = path[path.length - 1];
        const dist = Math.abs(head.r - r) + Math.abs(head.c - c);

        if (dist === 1) {
          // Backtrack logic
          if (path.length > 1) {
            const prev = path[path.length - 2];
            if (prev.r === r && prev.c === c) {
              path.pop();
              renderGrid();
              return;
            }
          }
          // Add new logic
          if (path.some(p => p.r === r && p.c === c)) return;

          const cellVal = level[r][c];
          const currentStep = path.length + 1;
          if (cellVal > 0 && cellVal !== currentStep) return; // Strict order

          path.push({ r, c });
          renderGrid();

          if (path.length === 25 && level[r][c] === 25) {
            isDrawing = false;
            bonusIlluminated = true;
            renderGrid();
            setTimeout(() => { showAlert('Heart Completed! â¤', 'You successfully traced the heart shape!'); markComplete('zip'); }, 200);
          }
        }
      }

      function handleTouchMove(e) {
        e.preventDefault();
        if (!isDrawing) return;
        const touch = e.touches[0];
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        if (el && el.classList.contains('zip-cell') && !el.classList.contains('void')) {
          // Calculate grid pos based on index
          const children = Array.from(document.getElementById('zipGrid').children);
          const idx = children.indexOf(el);
          const r = Math.floor(idx / 7);
          const c = idx % 7;
          enterCell(r, c);
        }
      }

      window.resetZip = function () { path = []; bonusIlluminated = false; renderGrid(); }
      document.body.onmouseup = () => isDrawing = false;
      document.body.ontouchend = () => isDrawing = false;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME 2: 6x6 SUDOKU (Boxes 2x3)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function createSudoku() {
      return `<style>
.sudoku-grid{display:grid;grid-template-columns:repeat(6,42px);grid-template-rows:repeat(6,42px);gap:0;margin:0 auto;justify-content:center;border:2px solid var(--accent);}
.sudoku-cell{background:rgba(201,64,96,0.05);border:1px solid rgba(201,64,96,0.15);display:flex;align-items:center;justify-content:center;font-size:1.1rem;color:var(--text-title);cursor:pointer;transition:background 0.2s;}
.sudoku-cell:hover:not(.fixed){background:rgba(201,64,96,0.15);}
.sudoku-cell.fixed{background:rgba(201,64,96,0.12);cursor:default;font-weight:bold;color:var(--accent);}
/* 6x6 Borders: Boxes are 2 Rows x 3 Cols */
.sudoku-cell:nth-child(3n){border-right:2px solid var(--accent);} /* Vert line every 3 cols */
.sudoku-cell:nth-child(6n){border-right:1px solid rgba(201,64,96,0.15);} /* Reset right edge */
.sudoku-cell:nth-child(n+7):nth-child(-n+12), .sudoku-cell:nth-child(n+19):nth-child(-n+24){border-bottom:2px solid var(--accent);} /* Horiz line every 2 rows */
.sudoku-controls{margin-top:16px;display:flex;gap:8px;justify-content:center;flex-wrap:wrap;}
.sudoku-num{width:36px;height:36px;background:rgba(201,64,96,0.1);border:1px solid rgba(201,64,96,0.2);border-radius:4px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:1rem;color:var(--text-title);transition:all 0.2s;}
.sudoku-num:hover{background:var(--accent);color:#fff;transform:scale(1.1);}
.sudoku-num.selected{background:var(--accent);color:#fff;}
</style>
<div class="sudoku-grid" id="sudokuGrid"></div>
<div class="sudoku-controls">
  <div class="sudoku-num" onclick="selectNum(1)">1</div>
  <div class="sudoku-num" onclick="selectNum(2)">2</div>
  <div class="sudoku-num" onclick="selectNum(3)">3</div>
  <div class="sudoku-num" onclick="selectNum(4)">4</div>
  <div class="sudoku-num" onclick="selectNum(5)">5</div>
  <div class="sudoku-num" onclick="selectNum(6)">6</div>
  <div class="sudoku-num" onclick="selectNum(0)">âœ•</div>
</div>`;
    }

    function initSudoku() {
      const solution = [
        [1, 2, 3, 4, 5, 6],
        [4, 5, 6, 1, 2, 3],
        [2, 3, 1, 5, 6, 4],
        [5, 6, 4, 2, 3, 1],
        [3, 1, 2, 6, 4, 5],
        [6, 4, 5, 3, 1, 2]
      ];
      const puzzle = [
        [1, 2, 3, 4, 5, 6],
        [0, 5, 0, 1, 0, 0],
        [0, 3, 1, 5, 0, 4],
        [5, 6, 4, 2, 3, 0],
        [3, 0, 2, 6, 4, 0],
        [6, 4, 5, 3, 0, 0]
      ];

      const current = puzzle.map(r => [...r]);
      let selectedNum = 0;

      window.selectNum = function (num) {
        selectedNum = num;
        document.querySelectorAll('.sudoku-num').forEach(el => el.classList.remove('selected'));
        if (num > 0) event.target.classList.add('selected');
      };

      renderSudoku();

      function renderSudoku() {
        const el = document.getElementById('sudokuGrid');
        el.innerHTML = '';
        current.forEach((row, r) => {
          row.forEach((val, c) => {
            const cell = document.createElement('div');
            const isFixed = puzzle[r][c] !== 0;
            cell.className = 'sudoku-cell' + (isFixed ? ' fixed' : '');
            cell.textContent = val || '';
            if (!isFixed) {
              cell.onclick = () => {
                if (selectedNum >= 0) { current[r][c] = selectedNum; }
                renderSudoku();
                checkSudoku();
              };
            }
            el.appendChild(cell);
          });
        });
      }

      function checkSudoku() {
        let complete = true;
        for (let r = 0; r < 6; r++) {
          for (let c = 0; c < 6; c++) {
            if (current[r][c] === 0) complete = false;
            else if (current[r][c] !== solution[r][c]) return;
          }
        }
        if (complete) { setTimeout(() => { showAlert('Perfect Sudoku!', 'You solved the puzzle correctly!'); markComplete('sudoku'); }, 300); }
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME 3: 4 QUEENS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function createQueens() {
      return `<style>
.queens-grid{display:grid;grid-template-columns:repeat(4,60px);grid-template-rows:repeat(4,60px);gap:0;margin:0 auto;justify-content:center;border:1px solid rgba(201,64,96,0.3);}
.queens-cell{background:rgba(201,64,96,0.05);border:1px solid rgba(201,64,96,0.1);display:flex;align-items:center;justify-content:center;font-size:1.8rem;cursor:pointer;transition:background 0.2s;}
.queens-cell:hover{background:rgba(201,64,96,0.15);}
.queens-cell.queen{background:rgba(201,64,96,0.2);}
</style>
<div class="queens-grid" id="queensGrid"></div>`;
    }

    function initQueens() {
      const board = Array(16).fill(false);
      renderQueens();
      function renderQueens() {
        const el = document.getElementById('queensGrid');
        el.innerHTML = '';
        board.forEach((hasQueen, i) => {
          const cell = document.createElement('div');
          cell.className = 'queens-cell' + (hasQueen ? ' queen' : '');
          cell.textContent = hasQueen ? 'â™›' : '';
          cell.onclick = () => {
            board[i] = !board[i];
            renderQueens();
            if (board.filter(Boolean).length === 4 && checkQueens()) {
              setTimeout(() => { showAlert('Brilliant!', 'You placed all 4 queens correctly!'); markComplete('queens'); }, 200);
            }
          };
          el.appendChild(cell);
        });
      }
      function checkQueens() {
        const positions = board.map((v, i) => v ? i : -1).filter(x => x >= 0);
        if (positions.length !== 4) return false;
        for (let i = 0; i < 4; i++) {
          for (let j = i + 1; j < 4; j++) {
            const r1 = Math.floor(positions[i] / 4), c1 = positions[i] % 4;
            const r2 = Math.floor(positions[j] / 4), c2 = positions[j] % 4;
            if (r1 === r2 || c1 === c2 || Math.abs(r1 - r2) === Math.abs(c1 - c2)) return false;
          }
        }
        return true;
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME 4: MEMORY MATCH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function createTango() {
      return `<style>
.tango-grid{display:grid;grid-template-columns:repeat(4,60px);grid-template-rows:repeat(2,60px);gap:8px;margin:0 auto;justify-content:center;}
.tango-card{background:rgba(201,64,96,0.1);border:1px solid rgba(201,64,96,0.2);border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:1.5rem;cursor:pointer;transition:transform 0.2s;}
.tango-card.flipped{background:rgba(201,64,96,0.2);transform:rotateY(180deg);}
.tango-card.matched{opacity:0.3;pointer-events:none;}
</style>
<div class="tango-grid" id="tangoGrid"></div>`;
    }

    function initTango() {
      const icons = ['ğŸ’•', 'ğŸŒ¹', 'ğŸ’', 'ğŸ’Œ'];
      const deck = [...icons, ...icons].sort(() => Math.random() - 0.5);
      let flipped = [];
      let matched = 0;

      renderTango();
      function renderTango() {
        const el = document.getElementById('tangoGrid');
        el.innerHTML = '';
        deck.forEach((icon, i) => {
          const card = document.createElement('div');
          card.className = 'tango-card';
          card.onclick = () => {
            if (flipped.length < 2 && !card.classList.contains('flipped')) {
              card.classList.add('flipped');
              card.textContent = icon;
              flipped.push({ card, icon });
              if (flipped.length === 2) {
                if (flipped[0].icon === flipped[1].icon) {
                  setTimeout(() => {
                    flipped.forEach(f => f.card.classList.add('matched'));
                    matched += 2;
                    flipped = [];
                    if (matched === 8) setTimeout(() => { showAlert('Amazing!', 'You found all the matching pairs!'); markComplete('tango'); }, 300);
                  }, 500);
                } else {
                  setTimeout(() => {
                    flipped.forEach(f => { f.card.classList.remove('flipped'); f.card.textContent = ''; });
                    flipped = [];
                  }, 800);
                }
              }
            }
          };
          el.appendChild(card);
        });
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FINAL PUZZLE ASSEMBLY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showFinalPuzzle() {
      document.getElementById('finalSection').classList.add('show');

      // Define the CORRECT mapping: piece ID -> slot position
      const correctMapping = {
        0: 0,  // piece 0 goes in slot 0 (top-left)
        1: 1,  // piece 1 goes in slot 1 (top-right)
        2: 2,  // piece 2 goes in slot 2 (bottom-left)
        3: 3   // piece 3 goes in slot 3 (bottom-right)
      };

      const pieces = [
        { id: 0, src: 'photo9_1.jpg' },
        { id: 1, src: 'photo9_2.jpg' },
        { id: 2, src: 'photo9_3.jpg' },
        { id: 3, src: 'photo9_4.jpg' }
      ];

      // Scramble the pieces initially
      const scrambledPieces = [...pieces].sort(() => Math.random() - 0.5);

      const slotState = {}; // Track which piece is in which slot

      renderPuzzle();

      function renderPuzzle() {
        const pool = document.getElementById('piecesPool');
        pool.innerHTML = '';

        scrambledPieces.forEach(p => {
          const wrap = document.createElement('div');
          wrap.className = 'piece-wrap';
          wrap.dataset.id = p.id;

          // Check if this piece is already placed
          const isPlaced = Object.values(slotState).includes(p.id);
          if (isPlaced) {
            wrap.classList.add('placed');
          }

          wrap.innerHTML = `<img src="${p.src}" class="puzzle-piece" draggable="true">`;
          wrap.ondragstart = (e) => e.dataTransfer.setData('pieceId', p.id);
          wrap.onclick = () => quickPlace(p.id);
          pool.appendChild(wrap);
        });

        document.querySelectorAll('.puzzle-slot').forEach(slot => {
          slot.ondragover = (e) => e.preventDefault();
          slot.ondrop = (e) => {
            e.preventDefault();
            const pieceId = parseInt(e.dataTransfer.getData('pieceId'));
            placePiece(pieceId, parseInt(slot.dataset.slot));
          };
        });
      }

      function quickPlace(pieceId) {
        const emptySlot = [...document.querySelectorAll('.puzzle-slot')].find(s => !s.classList.contains('filled'));
        if (emptySlot) placePiece(pieceId, parseInt(emptySlot.dataset.slot));
      }

      function placePiece(pieceId, slotId) {
        const slot = document.querySelector(`.puzzle-slot[data-slot="${slotId}"]`);
        const pieceData = pieces.find(p => p.id === pieceId);
        const correctSlot = correctMapping[pieceId];

        // Remove piece from previous slot if it was placed elsewhere
        Object.keys(slotState).forEach(key => {
          if (slotState[key] === pieceId) {
            const oldSlot = document.querySelector(`.puzzle-slot[data-slot="${key}"]`);
            oldSlot.classList.remove('filled', 'correct');
            oldSlot.innerHTML = '';
            delete slotState[key];
          }
        });

        if (!slot.classList.contains('filled')) {
          // Check if piece is being placed in correct slot
          if (slotId === correctSlot) {
            // Correct placement
            slot.classList.add('filled', 'correct');
            slot.innerHTML = `<img src="${pieceData.src}">`;
            slotState[slotId] = pieceId;

            renderPuzzle();

            // Check if puzzle is complete
            if (Object.keys(slotState).length === 4) {
              setTimeout(() => {
                document.getElementById('assemblyGrid').classList.add('complete');
                showAlert('Perfect! ğŸ’•', 'You revealed the complete picture!');
              }, 500);
            }
          } else {
            // Wrong placement - shake and return to pool
            slot.classList.add('filled');
            slot.innerHTML = `<img src="${pieceData.src}">`;
            slot.style.animation = 'shake 0.5s';

            setTimeout(() => {
              slot.style.animation = '';
              slot.classList.remove('filled');
              slot.innerHTML = '';
              renderPuzzle();
            }, 500);
          }
        }
      }

      window.redoPuzzle = function () {
        // Clear all slots
        document.querySelectorAll('.puzzle-slot').forEach(slot => {
          slot.classList.remove('filled', 'correct');
          slot.innerHTML = '';
        });

        // Remove complete class
        document.getElementById('assemblyGrid').classList.remove('complete');

        // Clear slot state
        Object.keys(slotState).forEach(key => delete slotState[key]);

        // Re-scramble pieces
        scrambledPieces.sort(() => Math.random() - 0.5);

        renderPuzzle();
      };
    }

    init();
  </script>
</body>

</html>